# -*- coding: utf-8 -*-
# Generated by Django 1.11.20 on 2021-02-04 16:16
from __future__ import unicode_literals

from django.db import migrations

from common.utils import DotDict
from collections import OrderedDict
import os


RUNNING_ENV = os.getenv('RUNNING_ENV', 'development')

if RUNNING_ENV == 'development' or RUNNING_ENV == 'local':
    LITCH_DB_NAME = 'litchi'
elif RUNNING_ENV == 'stage':
    LITCH_DB_NAME = "APPLITCHI_STAGE"
elif RUNNING_ENV == 'production':
    LITCH_DB_NAME = 'APPLITCHI'
else:
    raise KeyError(f"Unsupported RUNNING_ENV({RUNNING_ENV})")


class KBTendencyMapper:
    fount_kb_answer_keys = [
        'age_flag',
        'investable_period_flag',
        'income_flag',
        'salary_flag',
        'excess_cash_flag',
        'investment_per_financial_asset_flag',
        'financial_asset_per_capital_flag',
        'experienced_product_flag',
        'experience_period_flag',
        'investment_period',
        'purpose_flag',
        'knowledge_flag',
        'risk_tolerance_flag',
        'weak_finance_customer_flag',
        'info_offer_flag'
    ]

    FOUNT_ANSWER = DotDict({
        'NO': 0,
        'YES': 1,
        'A': 0,
        'B': 1,
        'C': 2,
        'D': 3,
        'E': 4
    })

    SH_ANSWER = DotDict({
        'NO': 0,
        'YES': 1,
        'A': 1,
        'B': 2,
        'C': 3,
        'D': 4,
        'E': 5
    })

    KB_ANSWER = DotDict({
        'YES': 0,
        'NO': 1,

        'A': 1,
        'B': 2,
        'C': 3,
        'D': 4,
        'E': 5,
        "FOR_0M": "0000",
        "FOR_6M": "0006",
        "FOR_1Y6M": "0106",
        "FOR_3Y": "0300"
    })

    fount_default_map = {FOUNT_ANSWER.A: KB_ANSWER.A, FOUNT_ANSWER.B: KB_ANSWER.B,
                         FOUNT_ANSWER.C: KB_ANSWER.C, FOUNT_ANSWER.D: KB_ANSWER.D, FOUNT_ANSWER.E: KB_ANSWER.E}
    fount_kb_mapper = OrderedDict([
        ('income_flag', {SH_ANSWER.A: KB_ANSWER.A,
                         SH_ANSWER.B: KB_ANSWER.B,
                         SH_ANSWER.C: KB_ANSWER.C}),  # Q1
        ('financial_asset_per_capital_flag', {SH_ANSWER.A: KB_ANSWER.A,
                                              SH_ANSWER.B: KB_ANSWER.A,
                                              SH_ANSWER.C: KB_ANSWER.B,
                                              SH_ANSWER.D: KB_ANSWER.C,
                                              SH_ANSWER.E: KB_ANSWER.D}),  # Q2
        ('invest_experience-A1', {}),  # Q3-A1
        ('invest_experience-A2', {}),  # Q3-A2
        ('invest_experience-B1', {}),  # Q3-B1
        ('invest_experience-B2', {}),  # Q3-B2
        ('invest_experience-C1', {}),  # Q3-C1
        ('invest_experience-C2', {}),  # Q3-C2
        ('no_invest_experience', {}),  # Q3-NULL_CASE
        ('purpose_flag', {SH_ANSWER.A: KB_ANSWER.D,
                          SH_ANSWER.B: KB_ANSWER.B,
                          SH_ANSWER.C: KB_ANSWER.A,
                          }),  # Q4
        ('risk_tolerance_flag', {SH_ANSWER.A: KB_ANSWER.A,
                                 SH_ANSWER.B: KB_ANSWER.B,
                                 SH_ANSWER.C: KB_ANSWER.C,
                                 SH_ANSWER.D: KB_ANSWER.D}),  # Q5
        ('knowledge_flag', {SH_ANSWER.A: KB_ANSWER.A,
                            SH_ANSWER.B: KB_ANSWER.B,
                            SH_ANSWER.C: KB_ANSWER.C,
                            SH_ANSWER.D: KB_ANSWER.D}),  # Q6
        ('investment_period', {SH_ANSWER.A: KB_ANSWER.FOR_0M,
                               SH_ANSWER.B: KB_ANSWER.FOR_6M,
                               SH_ANSWER.C: KB_ANSWER.FOR_1Y6M,
                               SH_ANSWER.D: KB_ANSWER.FOR_3Y}),  # Q7
        ('weak_finance_customer_flag', {SH_ANSWER.A: KB_ANSWER.YES,
                                        SH_ANSWER.B: KB_ANSWER.NO}),  # Q8
        ('info_offer_flag', {SH_ANSWER.A: KB_ANSWER.NO,
                             SH_ANSWER.B: KB_ANSWER.YES}),  # Q9
        # extra questions
        ('experienced_product_flag', fount_default_map),
        ('experience_period_flag', fount_default_map),
        ('investable_period_flag', fount_default_map),
        ('excess_cash_flag', fount_default_map),
        ('investment_per_financial_asset_flag', fount_default_map),
        ('salary_flag', fount_default_map),
        ('age_flag', fount_default_map)
    ])

    @classmethod
    def map_question_answer(cls, answers):
        response = OrderedDict()
        mapper_items = cls.fount_kb_mapper.items()
        for idx, (_answer, (k, mapper)) in enumerate(zip(answers, mapper_items), start=1):
            if mapper and _answer in mapper:
                if isinstance(_answer, list):  # multiple answers
                    pass  # NO case for multiple choice mapping
                elif isinstance(_answer, int):
                    _answer = mapper[_answer]
                    response[k] = _answer
                else:
                    raise TypeError("answer must be list[str] or str")

        mapped_answers = []
        for _answer_key in cls.fount_kb_answer_keys:
            mapped_answers.append(response[_answer_key])
        return mapped_answers

    @classmethod
    def unmap_question_answer(cls, answers):
        response = OrderedDict()
        unmapper = {k: {_v: _k for _k, _v in v.items()} for k, v in cls.fount_kb_mapper.items()}

        for question_key, a in zip(cls.fount_kb_answer_keys, answers):
            unmapper_dic = unmapper[question_key]
            unmapped = unmapper_dic.get(a)
            response[question_key] = unmapped

        unmapped_results = []
        for k in list(cls.fount_kb_mapper.keys())[-7:]:
            unmapped_results.append(response[k])
        return unmapped_results


def map_kb_tendency(apps, schema_editor):
    VendorProperty = apps.get_model('users', 'vendorproperty')
    VendorTendency = apps.get_model('users', 'vendortendency')
    Tendency = apps.get_model('users', 'tendency')
    try:
        kb_vendor = VendorProperty.objects.get(code='kb').user
        mapped_counts = 0
        for kb_tendency in VendorTendency.objects.filter(vendor=kb_vendor):
            if len(kb_tendency.result) == 7:
                tendency = Tendency.objects.get(user=kb_tendency.user)
                unmapped_tendency = tendency.result + kb_tendency.result

                mapped_tendency = KBTendencyMapper.map_question_answer(unmapped_tendency)
                kb_tendency.result = mapped_tendency
                kb_tendency.save()
                mapped_counts += 1

            elif len(kb_tendency.result) == 15:
                pass
            else:
                print("ERROR", kb_tendency.__dict__, kb_tendency.result)
        print(f"Total mapped: {mapped_counts}")
    except:
        pass


def unmap_kb_tendency(apps, schema_editor):
    print("\nRUN Unmaping")
    VendorProperty = apps.get_model('users', 'vendorproperty')
    VendorTendency = apps.get_model('users', 'vendortendency')

    kb_vendor = VendorProperty.objects.get(code='kb').user
    unmapped_counts = 0

    for kb_tendency in VendorTendency.objects.filter(vendor=kb_vendor):
        if len(kb_tendency.result) == 7:
            pass
        elif len(kb_tendency.result) == 15:
            unmapped_tendency = KBTendencyMapper.unmap_question_answer(kb_tendency.result)
            kb_tendency.result = unmapped_tendency
            kb_tendency.save()
            unmapped_counts += 1
        else:
            print("ERROR", kb_tendency.__dict__, kb_tendency.result)
    print(f"Total unmapped: {unmapped_counts}")


class Migration(migrations.Migration):
    dependencies = [
        ('users', '0019_update_profile'),
    ]

    operations = [
        migrations.RunPython(
            code=map_kb_tendency,
            reverse_code=unmap_kb_tendency
        ),
        migrations.RunSQL(
            sql=[
                f"""
                INSERT INTO {LITCH_DB_NAME}.users_vendortendency 
                (`id`, `result`, `forwarded_at`, `created_at`, `updated_at`, `user_id`, `vendor_id`)
                SELECT users_user.id AS id, `result`, null AS forwarded_at, CURRENT_TIMESTAMP() AS created_at, CURRENT_TIMESTAMP() AS updated_at, users_user.id AS user_id, 
                (SELECT id FROM {LITCH_DB_NAME}.users_user JOIN {LITCH_DB_NAME}.users_vendor_property ON {LITCH_DB_NAME}.users_user.id = {LITCH_DB_NAME}.users_vendor_property.user_id WHERE {LITCH_DB_NAME}.users_vendor_property.code = 'shinhan') AS vendor_id
                FROM {LITCH_DB_NAME}.users_tendency LEFT JOIN {LITCH_DB_NAME}.users_user ON users_user.id = users_tendency.user_id
                WHERE is_vendor=0 
                and users_user.id NOT in (SELECT id FROM {LITCH_DB_NAME}.users_vendortendency)
                """,
            ],
            reverse_sql=[
                f"""
                DELETE FROM {LITCH_DB_NAME}.users_vendortendency 
                WHERE vendor_id = (
                    SELECT id FROM {LITCH_DB_NAME}.users_user 
                    JOIN {LITCH_DB_NAME}.users_vendor_property ON {LITCH_DB_NAME}.users_user.id = {LITCH_DB_NAME}.users_vendor_property.user_id 
                    WHERE {LITCH_DB_NAME}.users_vendor_property.code = 'shinhan' and is_vendor=1);
                """
            ]
        )
    ]
